移除无效的括号
class Solution {

  //最终无重复的结果集
  private Set<String> validExpressions = new HashSet<String>();
  private int minimumRemoved;

  private void reset() {
    this.validExpressions.clear();
    this.minimumRemoved = Integer.MAX_VALUE;
  }

  private void recurse(String s,int index,int leftCount,int rightCount,StringBuilder expression,int removedCount) {

    // If we have reached the end of string.
    if (index == s.length()) {

      // If the current expression is valid.
      if (leftCount == rightCount) {

        // If the current count of removed parentheses is <= the current minimum count
        if (removedCount <= this.minimumRemoved) {
          String possibleAnswer = expression.toString();

          // If the current count beats the overall minimum we have till now
          if (removedCount < this.minimumRemoved) {
            this.validExpressions.clear();
            this.minimumRemoved = removedCount;
          }
          this.validExpressions.add(possibleAnswer);
        }
      }
    } else {
      char currentCharacter = s.charAt(index);
      int length = expression.length();

      if (currentCharacter == '(' || currentCharacter == ')') {
         // Recursion where we delete the current character and move forward
        this.recurse(s, index + 1, leftCount, rightCount, expression, removedCount+1);
      }
      expression.append(currentCharacter);
      if (currentCharacter != '(' && currentCharacter != ')') {
       // If it's an parenthesis, consider it and recurse
        this.recurse(s, index + 1, leftCount, rightCount, expression, removedCount);
      }else if (currentCharacter == '(') {
          this.recurse(s, index + 1, leftCount + 1, rightCount, expression, removedCount);
      } else if (rightCount < leftCount) {
          // For a closing parenthesis, only recurse if right < left
          this.recurse(s, index + 1, leftCount, rightCount + 1, expression, removedCount);
      }

      // Undoing the append operation for other recursions.
      expression.deleteCharAt(length);
    }
  }

  public List<String> removeInvalidParentheses(String s) {
     this.reset();
     this.recurse(s, 0, 0, 0, new StringBuilder(), 0);
     return new ArrayList(this.validExpressions);
  }
}



